---
title: Python多线程、多进程、协程
tags: Python
comments: on
---


----------

> **进程** ：对于操作系统来说，一个任务就是一个进程（Process）   
> **线程** ：一个进程可能需要做很多事，就需要同时运行多个“子任务”，进程内的这些“子任务”称为线程（Thread）

----------

## **多进程**   
过去的单核CPU，也可以执行多任务，表面上每个任务都是交替执行的，但是由于CPU的执行速度太快，感觉就像所有任务都在同时执行一样。**真正的并行执行多任务只能在多核CPU上实现**。

<br>

Unix/Linux操作系统提供了 `fork()` 系统调用，调用一次，返回两次，因为操作系统自动把当前进程（父进程）复制了一份（子进程），分别在父进程和子进程内返回。子进程永远返回0，而父进程返回子进程的ID。一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用 `getppid()` 就可以拿到父进程的ID。

<br>

由于Windows没有fork调用，python提供 `multiprocessing` 模块实现跨平台版本的多进程。

----

## **多线程**
每个进程至少要干一件事，所以一个进程至少有一个线程（主线程）。多个线程可以同时执行，与多进程是一样也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看似同时执行一样。**真正地同时执行多线程需要多核CPU才可能实现**。

<br>

高级语言通常都内置多线程的支持，Python的线程是真正的Posix Thread，而不是模拟出来的线程。Python提供 `threading` 模块实现多线程。

<br>

多线程和多进程最大的不同在于，**多进程中同一个变量各自有一份拷贝存在于每个进程中**，互不影响，而**多线程中所有变量都由所有线程共享**，所以任何一个变量都可以被任何一个线程修改，因此线程之间共享数据最大的危险在于多个线程同时改一个变量，需要创建线程锁 `threading.Lock()`。

### Python 全局线程锁（GIL）
Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以**多线程在Python中只能交替执行**，即n个线程跑在n核CPU上，也只能用到1个核。

----

## **多进程 *PK* 多线程**
|          | 多进程 | 多线程 |
| :------: | :------: | :------: |
| **优点** | 稳定性高 | 效率更高 |
| **缺点** | 创建进程的代价大 | 稳定性差 |

>  **多进程中一个子进程崩溃了，不会影响主进程和其他子进程**   
>  **多线程中任何一个线程挂掉都可能直接造成整个进程崩溃**

### 计算(CPU)密集型任务
要进行大量的计算，消耗CPU资源，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数（**适合多进程**）。对于计算密集型任务，最好用C语言编写，Python这类脚本语言运行效率很低。
### IO密集型任务
涉及到网络、磁盘IO的任务，CPU消耗很少，任务的大部分时间都在等待IO操作完成。对于IO密集型任务，任务越多，CPU效率越高（但也有一个限度 | **适合多线程**）。常见的大部分任务都是IO密集型任务，如Web应用，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选。

----------

## **协程**
由于CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此才需要多进程模型或者多线程模型来支持多任务并发执行。


> **异步IO** ：当代码需要执行一个耗时的IO操作时，它**只发出IO指令，并不等待IO结果**，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。


异步IO模型需要一个**消息循环**，主线程不断地重复“读取消息-处理消息”这一过程。在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。

<br>

现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。充分利用操作系统提供的异步IO支持，就可以用**单进程单线程模型来执行多任务**，这种全新的模型称为**事件驱动模型**（ngnix）。
 
> **协程** ：又称微线程，纤程(Coroutine)。对于Python，**单线程的异步编程模型**称为协程。

### 协程与多线程相比的优势
- **协程的执行效率极高**。子程序切换不是线程切换，而是由程序自身控制，因此**没有线程切换的开销**，线程数量越多，协程的性能优势就越明显。
- **不需要多线程的锁机制**。只有一个线程，不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。
- 在多核CPU上采用**多进程+协程**的方式，既充分利用多核，又充分发挥协程的高效率，因此性能极高。

----------

## **Python异步编程**
> Python对协程的支持通过 **生成器（generator）**实现

`yield` 提供对协程的基本支持；`gevent` 第三方库提供对Python2&3完善的协程支持；Python3.4引入 `asyncio`，提供内置的异步IO支持。